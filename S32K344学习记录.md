# S32K344学习记录

## 0 芯片资料

### 0.1 评估版外观

![image-20251204191053354](E:\Typora\Date\assets\image-20251204191053354.png)



### 0.2 外设框图

![image-20251204191031067](E:\Typora\Date\assets\image-20251204191031067.png)





### 0.3 用户按键

![image-20251204191128998](E:\Typora\Date\assets\image-20251204191128998.png)





### 0.4 用户LED

![image-20251204191150766](E:\Typora\Date\assets\image-20251204191150766.png)



### 0.5 旋钮电位器

![image-20251204191213027](E:\Typora\Date\assets\image-20251204191213027.png)



### 0.6 调试接口

![image-20251204191246465](E:\Typora\Date\assets\image-20251204191246465.png)



### 0.7 CAN外设

![image-20251204191311666](E:\Typora\Date\assets\image-20251204191311666.png)、





### 0.8 LIN外设

![image-20251204191331687](E:\Typora\Date\assets\image-20251204191331687.png)



### 0.9 USB转串口

![image-20251204191353242](E:\Typora\Date\assets\image-20251204191353242.png)



### 0.10 车载以太网

![image-20251204191418476](E:\Typora\Date\assets\image-20251204191418476.png)![image-20251204191426054](E:\Typora\Date\assets\image-20251204191426054.png)







## 1 基础工程配置

### 1.1 引脚配置

![image-20251204190710570](E:\Typora\Date\assets\image-20251204190710570.png)

- 选择对应引脚开启为GPIO模式，选择输入或者输出

![image-20251204191543661](E:\Typora\Date\assets\image-20251204191543661.png)

- 下面继续调整其具体配置，上下拉输入，推挽开漏等模式



### 1.2 具体代码

#### 1.2.1 头文件解释

![image-20251204191836425](E:\Typora\Date\assets\image-20251204191836425.png)

##### 1.2.1.1 #include "Mcal.h"

- `#include "Mcal.h"`,MCAL 是嵌入式系统中**直接对接硬件**的最底层软件层，介于 MCU 硬件寄存器和上层软件（如 ECU 抽象层、应用层）之间，目的是屏蔽不同 MCU 的硬件差异，提供标准化的硬件操作接口。`Mcal.h`则是整个 MCAL 层的**统一入口**，相当于 MCAL 层的 “总控面板”。MCU 的硬件资源（GPIO、时钟、定时器、ADC、CAN、SPI 等）都对应 MCAL 的子模块（如`Mcal_GPIO`、`Mcal_Clock`、`Mcal_Timer`），`Mcal.h`会集中包含这些子模块的头文件，并声明公共接口，上层代码只需包含`Mcal.h`即可调用所有硬件操作函数，无需逐个包含子模块头文件。

##### 1.2.1.2 #include "sys.h"

- `#include "sys.h"` 是 C 语言的预处理指令，作用是将项目中自定义的 `sys.h` 头文件内容嵌入当前源文件；而 `sys.h` 是嵌入式开发（尤其 STM32、51 单片机等场景）中**高频出现的 “系统级基础配置头文件”**，是项目定制化的 “系统核心配置入口”，以下是详细解析：
- 集中存放项目最基础的 “系统级常量”，是整个项目的 “参数基准”：
  - 芯片核心时钟频率（如 STM32 的 SYSCLK、HCLK、PCLK1/2）；
  - 内核 / 中断相关配置（如 NVIC 中断优先级分组、SysTick 滴答定时器分频系数）；
  - 硬件相关的核心宏（如字节序定义、芯片型号适配宏）。

##### 1.2.1.3 volatile

- `volatile`：告诉编译器该变量可能被中断 / 硬件修改，禁止编译器优化（避免变量被缓存到寄存器导致读取错误）；



#### 1.2.2 预编译指令

![image-20251204192600517](E:\Typora\Date\assets\image-20251204192600517.png)

##### 1.2.2.1 LPUART6_INSTANCE

- 宏名（语义化命名）：
  - `LPUART6`：低功耗 UART6 外设（Low Power UART6）；
  - `INSTANCE`：“实例”，表示该外设在 MCU 中的编号 / 索引

##### 1.2.2.2 6U

-  宏值：-

  - `6`：该外设的实例编号（MCU 厂商规定，如 STM32 中 LPUART6 对应编号 6）；-
  - `U`：后缀，表示**无符号整数**（unsigned），避免有符号 / 无符号类型混用的隐式转换问题

- **核心：整数常量的类型后缀（嵌入式 90% 场景用这个）**

  整数后缀分「无符号系列」「长整型系列」「组合系列」，是嵌入式外设 / 寄存器 / 地址操作的核心规范：

  | 后缀    | 完整含义                             | 简写说明       | 写法示例     | 嵌入式核心场景                                           | 关键特点                                        |
  | ------- | ------------------------------------ | -------------- | ------------ | -------------------------------------------------------- | ----------------------------------------------- |
  | U/u     | unsigned int（无符号 int）           | 无符号整型     | 6U、100u     | 外设实例编号（如 LPUART6_INSTANCE=6U）、位操作、循环计数 | 32 位系统默认占 4 字节，避免有符号 / 无符号混用 |
  | L/l     | long（有符号长整型）                 | 长整型         | 6L、100l     | 有符号大数值（如传感器计数值、负数偏移）                 | 32 位系统占 4 字节，64 位占 8 字节              |
  | LL/ll   | long long（有符号超长整型）          | 超长整型       | 6LL、100ll   | 64 位有符号数值（如时间戳、大计数器）                    | 固定占 8 字节                                   |
  | UL/lu   | unsigned long（无符号长整型）        | 无符号长整型   | 6UL、100lu   | 寄存器基地址（如 0x40008000UL）、64 位系统外设编号       | 32 位占 4 字节，64 位占 8 字节                  |
  | ULL/llu | unsigned long long（无符号超长整型） | 无符号超长整型 | 6ULL、100llu | 超大无符号计数（如超时值、大数据量统计）                 | 固定占 8 字节                                   |

  #### 关键示例（嵌入式场景）

  ```c
  // 1. U（无符号int）：外设编号（最常用）
  #define TIM6_INSTANCE 6U
  #define I2C3_INSTANCE 3U
  
  // 2. UL（无符号long）：寄存器地址（嵌入式地址必用）
  #define LPUART6_BASE 0x40008000UL  // LPUART6寄存器基地址
  #define GPIOA_BASE   0x40010800UL  // GPIOA基地址
  
  // 3. ULL（无符号超长整型）：64位超时计数（如毫秒级时间戳）
  #define LPUART6_TIMEOUT 10000000000ULL  // 10秒超时（避免数值溢出）
  
  // 4. L（有符号长整型）：负数偏移（如寄存器位偏移）
  #define ERROR_OFFSET -6L  // 错误码偏移量（有符号）
  
  // 5. LL（有符号超长整型）：64位有符号数值（如温度累计值）
  int64_t temp_total = 1234567890123LL;
  
  // 6. 组合后缀（UL/LU等价，规范用大写UL）
  #define SPI6_BAUDRATE 1000000UL  // SPI6波特率（无符号长整型）
  ```

  若数字是浮点数（如 3.14、6.0），也可加后缀指定浮点类型，避免默认`double`占用过多内存：

  | 后缀 | 完整含义                | 写法示例    | 嵌入式场景                 | 特点                                |
  | ---- | ----------------------- | ----------- | -------------------------- | ----------------------------------- |
  | F/f  | float（单精度）         | 6.0F、3.14f | 传感器浮点运算（节省内存） | 占 4 字节，精度满足大部分嵌入式场景 |
  | L/l  | long double（长双精度） | 6.0L、3.14l | 高精度运算（极少用）       | 占 8/16 字节，嵌入式几乎不用        |
  
  #### 示例

  ```c
  // 单精度浮点（嵌入式优先用F，避免double）
  #define TEMP_THRESHOLD 25.5F  // 温度阈值（float类型）
  #define VOLTAGE_REF 3.3F      // 参考电压（3.3V，float）
  ```
  
  1. **大小写兼容，但优先大写**：`6U`和`6u`、`6UL`和`6ul`等价，但大写更易读（行业规范）；
  2. **组合后缀顺序无关**：`6UL`=`6LU`、`6ULL`=`6LLU`，推荐按「无符号 + 长度」写（如 UL/ULL）；
  3. **地址 / 外设必用无符号后缀**：寄存器地址（UL）、外设编号（U）、位操作（U），避免有符号隐式转换；
  4. **数值溢出必用长后缀**：超过`unsigned int`范围（32 位最大 4294967295），必须用 UL/ULL；
  5. **浮点优先用 F**：嵌入式 MCU（如 STM32）的 FPU 对`float`优化更好，比默认`double`更快、更省内存。





#### 1.2.3 代码初始化

![image-20251204195008331](E:\Typora\Date\assets\image-20251204195008331.png)

##### 1.2.3.1 Clock_Ip_Init()

```c
Clock_Ip_Init(&Clock_Ip_aClockConfig[0]);
```

- **含义**：调用 S32K3XX MCAL 的时钟驱动初始化函数，传入时钟配置表的第一个配置项地址；
  - `Clock_Ip`：AUTOSAR RTD 的时钟集成包（Integration Package）驱动；
  - `Clock_Ip_aClockConfig[0]`：预配置的时钟参数表（如内核时钟、外设时钟分频 / 倍频）；
- **作用**：初始化芯片所有时钟（核心时钟、AHB/APB 总线时钟、外设时钟），是所有外设初始化的前提（时钟未配置则外设无法工作）。



##### 1.2.3.2 IntCtrl_Ip_Init()

```c
IntCtrl_Ip_Init(&IntCtrlConfig_0);
```

- **含义**：调用中断控制器初始化函数，传入中断配置表`IntCtrlConfig_0`地址；
  - `IntCtrl_Ip`：S32K3XX 的中断控制器（NVIC）驱动；
  - `IntCtrlConfig_0`：预配置的中断参数（如中断优先级分组、外设中断使能）；
- **作用**：初始化中断控制器，配置中断优先级、使能必要的外设中断（如 UART/I2C 中断），保障中断正常响应。



##### 1.2.3.3 Siul2_Port_Ip_Init()

```c
	Siul2_Port_Ip_Init(NUM_OF_CONFIGURED_PINS0, g_pin_mux_InitConfigArr0);
```

- **含义**：调用 S32K3XX 的 SIUL2（系统集成单元）引脚复用初始化函数；
  - `Siul2_Port_Ip`：SIUL2 引脚驱动（S32K3XX 的引脚复用 / 配置核心驱动）；
  - `NUM_OF_CONFIGURED_PINS0`：需要配置的引脚总数；
  - `g_pin_mux_InitConfigArr0`：引脚配置表（如 LED / 按键 / UART 引脚的复用功能、上拉 / 下拉、速率）；
- **作用**：配置所有硬件引脚的功能（如将某引脚设为 GPIO 输出 / 输入、UART_TX/RX），是 GPIO/UART/I2C 外设使用的前提。



##### 1.2.3.4 delay_init()

```c
	delay_init(Get_Freq / 1000000); //初始化延迟函数需要核心频率,把读取到的频率传入函数。
```

- **含义**：调用用户自定义的延时初始化函数，传入核心时钟频率（单位：MHz，`Get_Freq/1000000`将 Hz 转为 MHz）；
- **作用**：根据核心时钟频率校准延时函数（如`delay_ms`）的计数基准，保证延时时间准确（不同时钟频率下，延时计数需要适配）。



##### 1.2.3.5 Lpuart_Uart_Ip_Init()

```c
	Lpuart_Uart_Ip_Init(LPUART6_INSTANCE, &Lpuart_Uart_Ip_xHwConfigPB_6);
```

- **含义**：调用 LPUART（低功耗 UART）驱动初始化函数；
  - `Lpuart_Uart_Ip`：S32K3XX 的 LPUART 驱动；
  - `LPUART6_INSTANCE`：LPUART6 外设实例编号（6U）；
  - `Lpuart_Uart_Ip_xHwConfigPB_6`：LPUART6 的硬件配置表（波特率、数据位、停止位、校验位等）；
- **作用**：初始化 LPUART6 外设，配置通信参数，使其能正常收发数据（后续`LPUART_printf`依赖此初始化）。



##### 1.2.3.6 Lpi2c_Ip_MasterInit()

```c
	Lpi2c_Ip_MasterInit(I2C_MASTER_INSTANCE, &I2c_Lpi2cMasterChannel0);
```

- **含义**：调用 LPI2C（低功耗 I2C）主设备初始化函数；
  - `Lpi2c_Ip`：S32K3XX 的 LPI2C 驱动；
  - `I2C_MASTER_INSTANCE`：I2C 主设备实例编号（宏定义，未显式写出）；
  - `I2c_Lpi2cMasterChannel0`：I2C 主通道配置表（地址、波特率、超时等）；
- **作用**：初始化 I2C 主设备（OLED 屏通常通过 I2C 通信，此初始化为 OLED 做准备）。



##### 1.2.3.7 oled_init()

```c
oled_init(); //OLED配置参数初始化
```

- **含义**：调用 OLED 屏初始化函数；
- **作用**：初始化 OLED 的通信参数（I2C 地址、显示模式）、清屏、设置显示坐标等，使其能正常显示字符。



#### 1.2.4 IO函数

##### 1.2.4.1 Siul2_Dio_Ip_WritePin(）

```c
Siul2_Dio_Ip_WritePin(LED1_RED_PORT, LED1_RED_PIN, 0U);
```

- 调用 SIUL2 GPIO 写引脚函数，将 LED1（红灯）的引脚置为 0（低电平，假设 LED 是低电平点亮）；
  - `Siul2_Dio_Ip_WritePin`：S32K3XX 的 GPIO 写引脚函数，参数为 “端口号、引脚号、电平值（0U/1U）；

##### 1.2.4.2 Siul2_Dio_Ip_TogglePins()

```c
Siul2_Dio_Ip_TogglePins(LED4_YELLOW_PORT, (1 << LED4_YELLOW_PIN));
```

- **含义**：调用 SIUL2 GPIO 翻转引脚函数，参数为 “LED4（黄灯）的端口号、引脚掩码（1 左移 LED4 引脚号，表示要翻转的引脚）”；
  - `TogglePins`：翻转引脚电平（0→1，1→0）；
- **作用**：让黄色 LED4 周期性闪烁（配合后续 100ms 延时）。



##### 1.2.4.3 Siul2_Dio_Ip_ReadPin()

```c
Siul2_Dio_Ip_ReadPin(KEY1_PORT, KEY1_PIN)
```

- **含义**：调用 SIUL2 GPIO 读取引脚函数，参数端口和引脚
- **作用**：读取KEY1_PORT,KEY1_PIN的引脚值



#### 1.2.5 OLED函数

<img src="E:\Typora\Date\assets\image-20251205135412209.png" alt="image-20251205135412209" style="zoom:67%;" />







## 2 定时器PIT

### 2.1 外设添加

#### 2.1.1 选择虚拟定时器

![image-20251205151708389](E:\Typora\Date\assets\image-20251205151708389.png)



#### 2.1.2 使能对应通道

![image-20251205151808347](E:\Typora\Date\assets\image-20251205151808347.png)





#### 2.1.3 基础设置

![image-20251208151217494](E:\Typora\Date\assets\image-20251208151217494.png)

- PitNotification 回调函数名称



#### 2.1.4 中断配置

![image-20251208151122713](E:\Typora\Date\assets\image-20251208151122713.png)













### 2.2 代码实现

#### 2.1.1 头文件

![image-20251205152017988](E:\Typora\Date\assets\image-20251205152017988.png)

#### 2.2.2 宏定义

![image-20251205152703079](E:\Typora\Date\assets\image-20251205152703079.png)

```c
/* PIT instance used - 0 */
#define PIT_INST_0 0U
```

- **含义**：注释说明 “使用 PIT 实例 0”，定义无符号常量`PIT_INST_0`，值为 0；
- **作用**：语义化表示 “S32K344 的 PIT0 外设实例编号”，替代魔法数字 0。

```c
/* PIT Channel used - 0 */
#define CH_0 0U
```

- **含义**：注释说明 “使用 PIT 通道 0”，定义无符号常量`CH_0`，值为 0；
- **作用**：语义化表示 “PIT0 的通道 0”（S32K3 的 PIT 外设包含多个独立通道，通道 0 是常用通道）。

```c
/* PIT time-out period - equivalent to 1s */
#define PIT_PERIOD 40000000
```

- **含义**：注释说明 “PIT 超时周期 = 1 秒”，定义常量`PIT_PERIOD`，值为 40000000；
- **作用**：作为 PIT0 通道 0 的 “重装载值”，结合 PIT 时钟频率（40MHz）实现 1 秒定时（周期 = 重装载值 / PIT 时钟频率 → 40000000/40000000=1 秒）。

```c
uint8_t pit_flag = 0;
```

- **含义**：定义全局 8 位无符号变量`pit_flag`，初始值 0；
- **作用**：PIT 中断与主循环的 “通信标志”—— 中断服务函数置 1，主循环检测到 1 后执行对应逻辑，执行完成后置 0。



#### 2.2.3 中断回调函数

##### 2.2.3.1 PIT_0_Notification()

![image-20251205153228949](E:\Typora\Date\assets\image-20251205153228949.png)

```c
void PIT_0_Notification(void)
{
	pit_flag = 1;
}
```

- **含义**：PIT0 通道 0 的中断回调函数（由 AUTOSAR MCAL 的 PIT 驱动绑定到中断服务函数）；
- **作用**：PIT0 通道 0 定时时间到触发中断时，自动调用此函数，将`pit_flag`置 1，通知主循环 “定时完成”。





#### 2.2.4 中断函数初始化

##### 2.2.4.1 IntCtrl_Ip_EnableIrq()

![image-20251205153540669](E:\Typora\Date\assets\image-20251205153540669.png)

```c
IntCtrl_Ip_EnableIrq(PIT0_IRQn);
```

- **含义**：调用中断控制器驱动的 “使能中断” 函数，参数`PIT0_IRQn`是 PIT0 的中断号（S32K344 的硬件中断号）；
- **作用**：在 NVIC 中开启 PIT0 的中断总开关，若不执行此句，PIT 中断无法响应。





#### 2.2.5 定时器核心初始化

![image-20251205153801322](E:\Typora\Date\assets\image-20251205153801322.png)

##### 2.2.5.1 Pit_Ip_Init()

```c
	  /* 初始化周期定时器 */
	    Pit_Ip_Init(PIT_INST_0, &PIT_0_InitConfig_PB);
```

- **含义**：注释说明 “初始化周期定时器”，调用 PIT 驱动的 “实例初始化” 函数，传入 “PIT0 实例” 和 “PIT0 全局配置表”；
- **作用**：初始化 PIT0 外设的全局参数（如时钟源选择、定时器模式、休眠模式是否工作等）。

##### 2.2.5.2 Pit_Ip_InitChannel()

```c
	    /* 初始化周期定时器通道0 */
	    Pit_Ip_InitChannel(PIT_INST_0, PIT_0_CH_0);
```

- **含义**：注释说明 “初始化周期定时器通道 0”，调用 PIT 驱动的 “通道初始化” 函数，传入 “PIT0 实例” 和 “PIT0 通道 0 配置表”；
- **作用**：初始化 PIT0 通道 0 的独立参数（如中断回调函数绑定 —— 将`PIT_0_Notification`绑定到通道 0 中断）。

##### 2.2.5.3 Pit_Ip_EnableChannelInterrupt()

```c
	    /* 使能中断 */
	    Pit_Ip_EnableChannelInterrupt(PIT_INST_0, CH_0);
```

- **含义**：注释说明 “使能中断”，调用 PIT 驱动的 “通道中断使能” 函数，传入 “PIT0 实例” 和 “通道 0”；
- **作用**：开启 PIT0 通道 0 的中断（仅开启通道级中断，需配合`IntCtrl_Ip_EnableIrq(PIT0_IRQn)`的全局中断使能）。

##### 2.2.5.4 Pit_Ip_StartChannel()

```c
	    /*
	     * 开始定时器
	     * 周期计算公式
	     * 周期(秒) = 重装载值  / PIT时钟(40mhz)
	     * 例:
	     * 期望周期为0.5秒 = 200000000(重装载值) / 40000000(PIT外设时钟)
	     *  */
	    Pit_Ip_StartChannel(PIT_INST_0, CH_0, PIT_PERIOD);//PIT_PERIOD为重装载值 此处设置为40000000
```

- **含义**：注释详细说D明 PIT 周期计算公式，调用 PIT 驱动的 “启动通道” 函数，传入 “PIT0 实例”“通道 0”“重装载值 40000000”；
- **作用**：启动 PIT0 通道 0 的定时 —— 定时器从 40000000 开始递减计数，减到 0 时触发中断，然后自动重载继续计数（周期 1 秒）。



## 3 EMIOS_PWM

### 3.1 外设添加

#### 3.1.1 添加 EMIOS 组件：

![image-20251208162422200](E:\Typora\Date\assets\image-20251208162422200.png)

 在配置界面左侧**Components**面板，展开**EMIOS** → 选择**Emios Pwm Ip**（PWM 功能模块）和**Emios Mcl Ip**（EMIOS 核心控制模块），双击添加到右侧**Configuration**区。

#### 3.1.2  配置 EMIOS_Mcl_Ip：
点击**Emios Mcl Ip**配置项，进入实例配置页面：

![image-20251208164540914](E:\Typora\Date\assets\image-20251208164540914.png)

- **Enable Emios Common Support**：使能

![image-20251208164620281](E:\Typora\Date\assets\image-20251208164620281.png)

| 选项                                 | 配置值           | 作用说明                                                     |
| ------------------------------------ | ---------------- | ------------------------------------------------------------ |
| `Em ios Instance`                    | `EMIOS_1`        | 选择 EMIOS 外设的**实例编号**：S32K344 包含多个 EMIOS 实例（如 EMIOS1、EMIOS2），此配置指定当前配置的是**EMIOS1 实例**，后续所有通道 / 总线均属于该实例。 |
| `Enable EMIOS freeze state`          | 未勾选（□）      | 调试冻结功能：・勾选→调试器暂停（如断点）时，EMIOS 计数器停止运行，PWM 输出也会暂停；・未勾选→调试暂停时，EMIOS 仍继续运行，PWM 输出不中断（适合需要持续 PWM 的场景）。 |
| `Em ios Mcl Enable Global Time Base` | 勾选（✓）        | 启用全局时基：让 EMIOS1 下的所有通道共享同一个时间基准，保证多通道 PWM / 定时器的同步性（避免不同通道时钟偏移）。 |
| `Em ios Channel`                     | `EMIOS_CH_23`    | 指定**主总线（Master Bus）绑定的 EMIOS 通道**：EMIOS 的 “主总线” 需要依托一个具体通道来提供时钟基准，此配置将 EMIOS1 的 23 号通道作为主总线的承载通道（后续 PWM 通道的时基由该总线提供）。 |
| `Master Bus Mode Type`               | `MCB_UP_COUNTER` | 主总线的计数模式：选择**向上计数模式**，计数器从 0 递增到周期值后重置，对应**边缘对齐 PWM**（最常用的 PWM 波形类型）。 |
| `Default period`                     | `32768`          | 主总线的**默认周期值**（计数器最大计数值）：是 PWM 频率的初始基准（后续代码可动态修改），频率计算公式为「PWM 频率 = EMIOS 模块时钟 / 周期值」。 |
| `PWM exclusive access`               | 勾选（✓）        | 主总线的功能独占性：设置该主总线**仅用于 PWM 功能**，禁止其他功能（如输入捕获、普通定时器）占用此总线，避免功能冲突，保证 PWM 资源的独占性。 |



#### 3.1.3 配置 EMIOS_PWM 通道：

![image-20251208165041365](E:\Typora\Date\assets\image-20251208165041365.png)

![image-20251208164354500](E:\Typora\Date\assets\image-20251208164354500.png)

点击**Emios Pwm Ip**配置项，进入通道配置页面：

##### 3.1.3.1 EMIOS 实例配置区

| 选项                | 配置值       | 作用说明                                                     |
| ------------------- | ------------ | ------------------------------------------------------------ |
| `Name`              | `PwmEmios_0` | 当前 PWM 配置项的自定义名称（仅用于配置工具标识，不影响硬件功能）。 |
| `Hardware instance` | `Emios_1`    | 指定该 PWM 通道所属的**EMIOS 硬件实例**（此处为 EMIOS1，与之前主总线配置的实例一致）。 |

##### 3.1.3.2 EMIOS 通道核心配置区（Emios Channels）

| 选项              | 配置值                                                  | 作用说明                                                     |
| ----------------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| `Channel Id`      | `CH_12`                                                 | PWM 通道编号（对应 EMIOS1 的 12 号通道，与硬件引脚复用的通道一致）。 |
| `Mode`            | `EMIOS_PWM_IP_MODE_OPWMB`                               | PWM 工作模式：选择**OPWMB 模式**（边缘对齐 PWM，计数器从 0 递增到周期值后重置，是最常用的 PWM 模式）。 |
| `Flag Generation` | `Trailing Edge`                                         | PWM 标志位（中断触发标志）的生成时机：选择**下降沿生成**（PWM 波形从有效电平转为无效电平时，触发标志位）；若选`Leading Edge`则为上升沿生成。 |
| `Counter Bus`     | `EMIOS_PWM_IP_BUS_A`                                    | PWM 通道的**计数器总线**：绑定到 EMIOS 的 BUS A（即之前配置的、由 EMIOS1_CH23 承载的主总线，PWM 频率由该总线的周期决定）。 |
| `PwmEmiosBusRef`  | `/Emios_Mcl_Ip/EmiosMcl/EmiosCommon/EMIOS_0_MasterBus0` | 关联的主总线配置：引用之前配置的 EMIOS 主总线（保证 PWM 通道与主总线时钟同步）。 |

##### 3.1.3.3 PWM 通道附加配置区

| 选项                        | 配置值                               | 作用说明                                                     |
| --------------------------- | ------------------------------------ | ------------------------------------------------------------ |
| `Freeze enable`             | 未勾选（□）                          | 调试冻结功能：・勾选→调试器暂停时，该 PWM 通道的计数器停止运行；・未勾选→调试暂停时，PWM 仍持续输出。 |
| `Output disable source`     | `EMIOS_PWM_IP_OUTPUT_DISABLE_NONE`   | PWM 输出禁用源：选择 “无”，表示 PWM 输出始终使能，不会被外部硬件 / 软件条件禁用。 |
| `Clock prescaler`           | `EMIOS_PWM_IP_CLOCK_DIV_1`           | 通道时钟预分频：分频比为 1（EMIOS 模块时钟直接输入通道，不分频，最大化 PWM 频率范围）。 |
| `Clock prescaler Alternate` | `EMIOS_PWM_IP_CLOCK_DIV_1`           | 备用预分频：仅在特定模式下生效，此处同样设为分频比 1。       |
| `Prescaler Clock Source`    | `EMIOS_PWM_IP_PS_SRC_MODULE_CLOCK`   | 预分频器时钟源：选择 “EMIOS 模块时钟”（与系统时钟配置中 EMIOS 的时钟源一致）。 |
| `Polarity`                  | `EMIOS_PWM_IP_ACTIVE_LOW`            | PWM 输出极性：**低电平有效**（PWM 的 “有效电平” 为低电平，占空比 = 低电平持续时间 / 周期；适合共阳 LED 等负载）。 |
| `Flag Event response`       | `EMIOS_PWM_IP_NOTIFICATION_DISABLED` | 标志位事件响应：禁用通知（即禁用 PWM 相关中断，若需中断可选择 “Interrupt”）。 |

##### 3.1.3.4 中断回调配置区（EmiosChIrqCallback）

| 选项                 | 配置值               | 作用说明                                                     |
| -------------------- | -------------------- | ------------------------------------------------------------ |
| `Name`               | `EmiosChIrqCallback` | 中断回调函数的自定义名称（仅用于配置工具标识）。             |
| `Callback function`  | `NULL_PTR`           | 中断回调函数：因`Flag Event response`已禁用中断，故设为`NULL`（无回调函数）。 |
| `Callback parameter` | `NULL_PTR`           | 回调函数参数：同样因中断禁用，设为`NULL`。                   |

##### 3.1.3.5 PWM 波形参数区

| 选项                  | 配置值  | 作用说明                                                     |
| --------------------- | ------- | ------------------------------------------------------------ |
| `Duty cycle [ticks]`  | `13685` | PWM 占空比计数值：有效电平的持续计数值（后续代码可动态修改，实现占空比调节）。 |
| `Period [ticks]`      | `32768` | PWM 周期计数值：计数器从 0 到该值的总时长（对应 PWM 频率，后续代码可动态修改，实现频率调节）。 |
| `Phase Shift [ticks]` | `0`     | 相位偏移：多通道 PWM 同步时的相位差，此处设为 0（无偏移）。  |
| `Trigger [ticks]`     | `0`     | 触发位置：用于触发其他外设的时刻，此处未使用，设为 0。       |
| `Deadtime [ticks]`    | `0`     | 死区时间：互补 PWM 输出时（如电机驱动），防止上下桥臂同时导通的间隔时间，此处未使用，设为 0。 |



#### 3.1.4 引脚设置

![image-20251208180656387](E:\Typora\Date\assets\image-20251208180656387.png)

![image-20251208180534044](E:\Typora\Date\assets\image-20251208180534044.png)

- 引脚复用，配置为EMIOS模式



### 3.2 代码实现

#### 3.2.1 头文件包含

![image-20251208170938168](E:\Typora\Date\assets\image-20251208170938168.png)

![image-20251208171125626](E:\Typora\Date\assets\image-20251208171125626.png)



#### 3.2.2 宏定义

![image-20251208171341795](E:\Typora\Date\assets\image-20251208171341795.png)



#### 3.2.3 函数设置

![image-20251208171602497](E:\Typora\Date\assets\image-20251208171602497.png)

##### 3.2.3.1 占空比计算函数`setDutyCycle`

```c
/*
 * 输入当前重装载值与期待占空比,返回值可以作为参数直接输入函数
 * Period 为重装载值
 * targetDutycycle 取值范围为0-1,如需要50%占空比 则输入0.5
 *
 * */
uint32_t setDutyCycle(uint32_t Period, float targetDutycycle) {
	uint32_t dutycycle = fabs(Period * targetDutycycle);
	return dutycycle;
}
```

- 功能：根据 PWM 的重装载值（Period）和目标占空比（0~1 的浮点数），计算 PWM 的占空比比较值（dutycycle）。
- `fabs`：取绝对值，防止负数输入导致错误；返回值为无符号 32 位整数，符合 EMIOS 寄存器的位宽要求。

##### 3.2.3.2  频率计算函数`setFrequency`

```c
/*
 * 输入Emios外设频率与期待PWM输出频率,返回值可以作为参数直接输入函数
 * Emios_clk 为重装载值
 * targetPwmFreq 取值单位为hz,,例如需要10Khz频率, 则输入10000.
 *
 * */
uint32_t setFrequency(uint32_t Emios_clk, float targetPwmFreq) {
	uint32_t period = abs(Emios_clk / targetPwmFreq);
	return period;
}
```

- 功能：根据 EMIOS 外设的时钟频率（Emios_clk）和目标 PWM 频率（targetPwmFreq，单位 Hz），计算 EMIOS 计数器的重装载值（period）。
- 原理：PWM 频率 = EMIOS 时钟频率 / 重装载值，因此重装载值 = EMIOS 时钟频率 / PWM 频率；`abs`取绝对值，避免除数为 0 或负数（实际需保证 targetPwmFreq>0）。



#### 3.2.4 变量定义

![image-20251208172701798](E:\Typora\Date\assets\image-20251208172701798.png)



#### 3.2.5 PWM初始化

![image-20251208173024065](E:\Typora\Date\assets\image-20251208173024065.png)

##### 3.2.5.1 EMIOS 外设初始化
```c
	Emios_Mcl_Ip_Init(INSTANCE_1, &Emios_Mcl_Ip_1_Config_BOARD_INITPERIPHERALS);

	Emios_Pwm_Ip_InitChannel(INSTANCE_1, &Emios_Pwm_Ip_I1_Ch12); //PTA29
```

- `Emios_Mcl_Ip_Init`：初始化 EMIOS 实例 1 的全局配置（如时钟源、工作模式等），`Emios_Mcl_Ip_1_Config_BOARD_INITPERIPHERALS`是 EMIOS 实例 1 的配置结构体（由图形配置工具生成）。
- `Emios_Pwm_Ip_InitChannel`：初始化 EMIOS 实例 1 的通道 12 为 PWM 输出模式，注释说明该通道对应引脚 PTA29；`Emios_Pwm_Ip_I1_Ch12`是通道 12 的 PWM 配置结构体（定义 PWM 极性、对齐方式等）。

##### 3.2.5.2 PWM 初始参数计算与配置
```c
	/*
	 * Get_Freq 变量为核心频率,此工程emios外设时钟与核心频率相等,所以可以直接使用
	 * 设置目标频率为10khz
	 * 然后将返回值导入频率配置函数即可得到预期的频率
	 * */
	Pwm_Period = setFrequency(Get_Freq, 10000);
	/*
	 *  PWM频率计算公式 频率 = (Emios总线频率(160mhz) / period)
	 *  Emios通道时钟由23通道提供,所以更改23通道时钟,就可以改变pwm频率
	 * */
	Emios_Mcl_Ip_SetCounterBusPeriod(INSTANCE_1, CHANNEL_23, Pwm_Period);

	/*    占空比公式  占空比 = (dutycycle / period ) , dutycycle大于period,则输出100%占空比*/
	Emios_Pwm_Ip_SetDutyCycle(INSTANCE_1, CHANNEL_12, 0);
```

- `setFrequency(Get_Freq, 10000)`：初始设置 PWM 频率为 10kHz，根据核心频率计算 EMIOS 的重装载值`Pwm_Period`。
- `Emios_Mcl_Ip_SetCounterBusPeriod`：设置 EMIOS 实例 1 的通道 23（计数器总线）的重装载值为`Pwm_Period`，通道 12 的 PWM 频率由通道 23 的计数器总线决定，因此修改通道 23 的周期可改变 PWM 频率。
- `Emios_Pwm_Ip_SetDutyCycle`：初始化 EMIOS 通道 12 的 PWM 占空比比较值为 0，即初始 PWM 输出为低电平（占空比 0%）。



#### 3.2.6 功能实现

![image-20251208173526394](E:\Typora\Date\assets\image-20251208173526394.png)

##### 3.2.6.1 按键 1 处理（占空比调节）
```c
		if (pinstate == BTN1_PRES) {

			target_Pwm_Dutycycle += 0.1;
			if (target_Pwm_Dutycycle > 1) {
				target_Pwm_Dutycycle = 0;
			}
			uint32_t dutycycle_val = setDutyCycle(Pwm_Period,target_Pwm_Dutycycle);
			Emios_Pwm_Ip_SetDutyCycle(INSTANCE_1, CHANNEL_12, dutycycle_val);
			LPUART_printf("占空比为 :%.1f ,比较值为 %d\r\n",
					target_Pwm_Dutycycle * 100.0, dutycycle_val);
		}
```

- 当按键 1 按下（`pinstate == BTN1_PRES`）时：
  - `target_Pwm_Dutycycle += 0.1`：占空比增加 10%（步长 0.1）。
  - `if (target_Pwm_Dutycycle > 1)`：若占空比超过 100%（1.0），则重置为 0%（循环调节）。
  - `setDutyCycle(Pwm_Period, target_Pwm_Dutycycle)`：计算占空比比较值`dutycycle_val`。
  - `Emios_Pwm_Ip_SetDutyCycle`：更新 EMIOS 通道 12 的 PWM 占空比比较值，实时改变 PWM 输出。
  - `LPUART_printf`：串口打印当前占空比（百分比，保留 1 位小数）和比较值（寄存器值），用于调试。

##### 3.2.6.2 按键 2 处理（频率调节）
```c
		else if (pinstate == BTN2_PRES) {

			target_freq += 10000;
			if (target_freq > 100000) {
				target_freq = 10000;
			}
			Pwm_Period = setFrequency(Get_Freq, target_freq);
			Emios_Mcl_Ip_SetCounterBusPeriod(INSTANCE_1, CHANNEL_23,
					Pwm_Period);
			LPUART_printf("PWM频率为 :%d hz ,重装载值 %d\r\n", target_freq,
					Pwm_Period);
		}
```

- 当按键 2 按下（`pinstate == BTN2_PRES`）时：
  - `target_freq += 10000`：频率增加 10kHz（步长 10000Hz）。
  - `if (target_freq > 100000)`：若频率超过 100kHz，则重置为 10kHz（循环调节）。
  - `setFrequency(Get_Freq, target_freq)`：根据新频率计算 EMIOS 重装载值`Pwm_Period`。
  - `Emios_Mcl_Ip_SetCounterBusPeriod`：更新 EMIOS 通道 23 的计数器总线周期，实时改变 PWM 频率。
  - `LPUART_printf`：串口打印当前 PWM 频率（单位 Hz）和重装载值（寄存器值），用于调试。

## 4 GPIO

### 4.1 芯片设置

#### 4.1.1 配置输出模式

![image-20251210140340383](E:\Typora\Date\assets\image-20251210140340383.png)

#### 4.1.2 具体配置

![image-20251210140512180](E:\Typora\Date\assets\image-20251210140512180.png)

- 设置即为推挽输出模式



### 4.2 函数设置

#### 4.2.1 宏定义端口

![image-20251210140647460](E:\Typora\Date\assets\image-20251210140647460.png)

- 明确核心映射关系（以 PTD27~PTD30 为例）

- 电机引脚的全局标识 / 端口分组如下：

| 电机引脚 | 全局引脚名 | 所属端口宏 | 端口组内局部编号（核心！）                       |
| -------- | ---------- | ---------- | ------------------------------------------------ |
| IN1      | PTD27      | PTD_H_HALF | 27 - 16 = 11（假设 PTD_H_HALF 对应 PTD16~PTD31） |
| IN2      | PTD28      | PTD_H_HALF | 28 - 16 = 12                                     |
| IN3      | PTD29      | PTD_H_HALF | 29 - 16 = 13                                     |
| IN4      | PTD30      | PTD_H_HALF | 30 - 16 = 14                                     |



#### 4.2.2 函数使用

##### 4.2.2.1 Siul2_Dio_Ip_WritePin(）

```c
Siul2_Dio_Ip_WritePin(LED1_RED_PORT, LED1_RED_PIN, 0U);
```

- 调用 SIUL2 GPIO 写引脚函数，将 LED1（红灯）的引脚置为 0（低电平，假设 LED 是低电平点亮）；
  - `Siul2_Dio_Ip_WritePin`：S32K3XX 的 GPIO 写引脚函数，参数为 “端口号、引脚号、电平值（0U/1U）；

##### 4.2.2.2 Siul2_Dio_Ip_TogglePins()

```c
Siul2_Dio_Ip_TogglePins(LED4_YELLOW_PORT, (1 << LED4_YELLOW_PIN));
```

- **含义**：调用 SIUL2 GPIO 翻转引脚函数，参数为 “LED4（黄灯）的端口号、引脚掩码（1 左移 LED4 引脚号，表示要翻转的引脚）”；
  - `TogglePins`：翻转引脚电平（0→1，1→0）；
- **作用**：让黄色 LED4 周期性闪烁（配合后续 100ms 延时）。

##### 4.2.2.3 Siul2_Dio_Ip_ReadPin()

```c
Siul2_Dio_Ip_ReadPin(KEY1_PORT, KEY1_PIN)
```

- **含义**：调用 SIUL2 GPIO 读取引脚函数，参数端口和引脚
- **作用**：读取KEY1_PORT,KEY1_PIN的引脚值



## 5 UART

### 5.1 外设配置

#### 5.1.1 引脚添加

![image-20251211101205088](E:\Typora\Date\assets\image-20251211101205088.png)

#### 5.1.2 串口配置

![image-20251211161135161](E:\Typora\Date\assets\image-20251211161135161.png)

![image-20251211102100512](E:\Typora\Date\assets\image-20251211102100512.png)

#### 5.1.3 中断田间

![image-20251211104727427](E:\Typora\Date\assets\image-20251211104727427.png)



### 5.2 代码实现

#### 5.2.1 宏与变量定义

##### 5.2.1.1 CHAR

```c
volatile int exit_code = 0;  // 全局退出标志（volatile防止编译器优化，确保内存实时访问）
/* User includes */
#include "sys.h"    // 系统相关自定义头文件（如时钟、中断辅助）
#include "uart.h"   // UART自定义封装（如LPUART_printf）
#include "delay.h"  // 延时函数头文件
#include "key.h"    // 按键驱动（代码中未实际使用）
#include "string.h" // 字符串操作库
```

- 宏定义：`LPUART6_INSTANCE`绑定硬件实例，增强代码可读性；
- 全局数组：`buffer`用于临时接收串口字节，`rxdata`存储完整接收数据；
- 标志位：`Uart_rx_flag`是主循环判断数据是否接收完成的核心标志

##### 5.2.1.2 HEX

![image-20251211160516288](E:\Typora\Date\assets\image-20251211160516288.png)





#### 5.2.2 回调函数

##### 5.2.2.1 CHAR

![image-20251211102826908](E:\Typora\Date\assets\image-20251211102826908.png)

```c
void Uart6_Callback(const uint8 HwInstance,
		const Lpuart_Uart_Ip_EventType Event, void *UserData) {

	(void) HwInstance;  // 未使用参数，强制编译无警告
	(void) UserData;    // 未使用参数，强制编译无警告
	volatile Lpuart_Uart_Ip_StatusType lpuartStatus =
			LPUART_UART_IP_STATUS_ERROR; // 初始化状态为错误
```

- 函数原型：符合 NXP LPUART 驱动的回调函数规范，中断触发时被调用；
- `(void)参数`：抑制未使用参数的编译警告；
- `volatile`修饰状态变量：确保中断中实时读取状态。

```c
	if (Lpuart_Uart_Ip_GetReceiveStatus(HwInstance, &bytesRemaining)
			!= LPUART_UART_IP_STATUS_BUSY) {
		lpuartStatus = Lpuart_Uart_Ip_GetReceiveStatus(HwInstance,
				&bytesRemaining); // 获取接收状态
		if (lpuartStatus == LPUART_UART_IP_STATUS_SUCCESS) {
			/* 为接收到的字符串添加终止符 */
			bufferIdx++;
			Uart_rx_flag = 1;          // 置位接收完成标志
			buffer[bufferIdx] = 0U;    // 字符串末尾加'\0'
			/* 将接收缓存复制到rxdata数组 */
			memcpy(rxdata, buffer, bufferIdx);
			memset(buffer, 0, sizeof(buffer)); // 清空临时缓存
			/* Reset the buffer index to start a new reception */
			bufferIdx = 0U;            // 重置索引，准备下次接收
			/* 重新开始异步接收（1字节） */
			Lpuart_Uart_Ip_AsyncReceive(HwInstance, buffer, 1);
		} else {
			// 接收错误：重新启动接收
			Lpuart_Uart_Ip_AsyncReceive(HwInstance, buffer, 1);
		}
	}
```

- 核心逻辑：判断接收状态是否为 “非忙”，若接收成功则处理数据：
  1. 置位`Uart_rx_flag`通知主循环；
  2. 给接收数据加字符串终止符（避免乱码）；
  3. 复制数据到`rxdata`，清空临时缓存；
  4. 重置索引并重新启动异步接收（保证串口持续监听）；
- 错误处理：接收失败时重新启动接收，避免串口卡死。

```c
	/*串口接收缓存满事件*/
	if (Event == LPUART_UART_IP_EVENT_RX_FULL) {
		/*判断是否收到换行符，且缓存未溢出*/
		if ((buffer[bufferIdx] != '\n') && (bufferIdx != (BUFFER_SIZE - 2U))) {
			/* 索引后移，准备接收下一字节 */
			bufferIdx++;
			/* 设置新的接收缓存位置（1字节） */
			Lpuart_Uart_Ip_SetRxBuffer(HwInstance, &buffer[bufferIdx], 1U);
		}
	}
}
```

- `LPUART_UART_IP_EVENT_RX_FULL`：串口接收缓存满事件（每接收 1 字节触发）；
- 逻辑：若未收到换行符且缓存未溢出，更新接收缓存位置，继续接收下一字节；
- 换行符`\n`是数据接收结束的隐性标志（代码中未显式处理，仅通过缓存满判断）。



##### 5.2.2.2 HEX

![image-20251211160612551](E:\Typora\Date\assets\image-20251211160612551.png)

![image-20251211160624132](E:\Typora\Date\assets\image-20251211160624132.png)

`LPUART_UART_IP_EVENT_RX_FULL`（简称`RX_FULL`）事件的 “满（full）”，**不是指硬件 FIFO 满，也不是指固定字节数，而是指「驱动层配置的异步接收缓冲区被填满」** —— 核心是 “配置的接收长度” 与 “实际收到的字节数” 匹配，具体结合代码和 S32K3 的 LPUART 驱动逻辑拆解如下：

 一、RX_FULL 触发的核心逻辑（驱动层 + 代码层）

S32K3 的`Lpuart_Uart_Ip`驱动是 “异步接收” 模式：我们先通过`Lpuart_Uart_Ip_AsyncReceive()`告诉驱动「要接收 N 个字节，并指定缓冲区存储」，当驱动从硬件读取到**恰好 N 个字节**并写入缓冲区后，就会触发`RX_FULL`事件，同时调用回调函数。

二、代码中 “满（full）” 的具体判定条件（关键！）

在你的代码中，RX_FULL 触发的 “满” 是**1 字节满**，核心源于两处配置：

 1. 初始异步接收配置（主函数中）

```c
Lpuart_Uart_Ip_AsyncReceive(LPUART1_INSTANCE, buffer, 1U);
```

- 第三个参数`1U`：告诉驱动「我要接收**1 个字节**，收到 1 个字节就认为缓冲区满」；
- `buffer`：指定驱动收到 1 字节后，写入这个 1 字节长度的缓冲区。

 2. 回调函数中重新配置（保证持续接收）

每次处理完`RX_FULL`后，都会重新配置 1 字节接收：

```c
Lpuart_Uart_Ip_SetRxBuffer(HwInstance, buffer, 1U);
```

- 这意味着：**驱动永远以「1 字节」为 “满” 的判定标准** —— 只要硬件收到 1 个字节，驱动就会把字节写入`buffer`，然后判定 “缓冲区满”，触发`RX_FULL`事件，调用回调函数。







#### 5.2.3 串口初始化

##### 5.2.3.1 CHAR

![image-20251211104325860](E:\Typora\Date\assets\image-20251211104325860.png)

```c
	/*  注册并使能LPUART1中断 */
	IntCtrl_Ip_InstallHandler(LPUART1_IRQn, LPUART_UART_IP_1_IRQHandler,
			NULL_PTR);
	IntCtrl_Ip_EnableIrq(LPUART1_IRQn);
	/*  LPUART1初始化（硬件配置） */
	Lpuart_Uart_Ip_Init(LPUART6_INSTANCE, &Lpuart_Uart_Ip_xHwConfigPB_1);
	/* 启动LPUART1异步接收（初始接收1字节） */
	Lpuart_Uart_Ip_AsyncReceive(LPUART6_INSTANCE, buffer, 1);
```

- 初始化流程遵循 AUTOSAR MCAL 规范：**时钟 → 中断 → 引脚 → 外设**；
- 关键步骤：
  - `IntCtrl_Ip_InstallHandler`：绑定 LPUART1 中断服务函数；
  - `Lpuart_Uart_Ip_AsyncReceive`：启动异步接收（非阻塞，中断触发）；



##### 5.2.3.2 HEX

![image-20251211160837756](E:\Typora\Date\assets\image-20251211160837756.png)





#### 5.2.4 功能实现

##### 5.2.4.3 CHAR

![image-20251211161009681](E:\Typora\Date\assets\image-20251211161009681.png)

##### 5.2.4.2 HEX

![image-20251211160904676](E:\Typora\Date\assets\image-20251211160904676.png)





## 6 CAN

### 6.1 外设配置























































































































































## ∞ 问题收集

###  ∞.1 程序进入`DevAssert`断言机制

![image-20251210141234665](E:\Typora\Date\assets\image-20251210141234665.png)

#### ∞.1.1 先理解`DevAssert`的作用

`DevAssert(x)`是一个**断言宏**，功能是：

- 检查括号里的条件`x`是否为`true`；
- 如果`x`为`true`：程序正常继续执行；
- 如果`x`为`false`：进入`else`分支，执行`for(;;)`（死循环）+ 断点指令（`ASM_KEYWORD(BREAKPOINT_INSTR)`），最终程序停在这里。

#### ∞.1.2 程序停止的直接原因

当前`DevAssert`的条件`x`为`false`，所以触发了断言的 “错误拦截逻辑”，程序被强制暂停。

#### ∞.1.3 核心问题：为什么条件`x`会是`false`？

`x`是调用`DevAssert`时传入的条件（比如 “外设初始化成功”“参数合法”“硬件状态正常” 等），常见的触发场景有：

- **参数错误**：比如给函数传了非法值（例如 GPIO 端口号超出范围）；
- **初始化失败**：比如外设（如 SIUL2、PIT、EMIOS）初始化返回了 “失败状态”，代码用`DevAssert(初始化结果)`检查，结果初始化失败导致条件为`false`；
- **资源未就绪**：比如尝试操作还没初始化的硬件（如没调用`Siul2_Port_Ip_Init`就操作 GPIO）；
- **配置不匹配**：比如代码里的宏定义（如引脚编号）和 S32 Configuration Tool 生成的配置不一致。



## 代码存档

### main.c

```c
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.7
*   Platform             : CORTEXM
*   Peripheral           : S32K3XX
*   Dependencies         : none
*
*   Autosar Version      : 4.7.0
*   Autosar Revision     : ASR_REL_4_7_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 3.0.0
*   Build Version        : S32K3_RTD_3_0_0_D2303_ASR_REL_4_7_REV_0000_20230331
*
*   Copyright 2020 - 2023 NXP Semiconductors
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

/**
*   @file main.c
*
*   @addtogroup main_module main module documentation
*   @{
*/

/* Including necessary configuration files. */
#include "Mcal.h"

volatile int exit_code = 0;
/* User includes */
#include "sys.h"
#include "uart.h"
#include "delay.h"
#include "key.h"
#include "StepperMotor.h"
#include "DirectMotor.h"
#include "string.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>

/*!
  \brief The main function for the project.
  \details The startup initialization sequence is the following:
 * - startup asm routine
 * - main()
*/

// 串口部分设置
#define LPUART6_INSTANCE  6U
#define LPUART1_INSTANCE  1U  // 修正重复定义问题
// PWM设置
#define INSTANCE_1        (uint8)1U
#define CHANNEL_12        (uint8)12U
#define CHANNEL_23        (uint8)23U

// 定时器部分设置
/* PIT instance used - 0 */
#define PIT_INST_0 0U
/* PIT Channel used - 0 */
#define CH_0 0U
/* PIT time-out period - equivalent to 1s */
#define PIT_PERIOD 800000

// ======================== HEX帧解析相关定义 ========================
// 帧格式：FF(帧头) + xx(数据字节) + EE(帧尾)
#define FRAME_HEADER 0xFF
#define FRAME_TAIL   0xEE
#define FRAME_LENGTH 3U  // 帧总长度

// 帧接收状态机枚举
typedef enum {
    FRAME_STATE_IDLE,    // 空闲态，等待帧头FF
    FRAME_STATE_DATA,    // 已收帧头，等待数据字节xx
    FRAME_STATE_TAIL     // 已收数据，等待帧尾EE
} FrameReceiveStateType;

// 帧接收相关变量
static FrameReceiveStateType frameState = FRAME_STATE_IDLE;  // 帧接收状态
static uint8_t rxFrameBuffer[FRAME_LENGTH] = {0};           // 帧接收缓冲区
static uint8_t rxFrameIndex = 0U;                            // 帧接收字节索引
uint8_t validFrameReceived = 0U;                            // 有效帧接收完成标志
uint8_t rxDataByte = 0U;                                    // 解析出的有效数据字节（xx）
// =========================================================================

// 仅用于接收单个字
uint8_t buffer[1] = {0};
uint32_t bytesRemaining;

volatile uint8_t pit_flag = 0;

extern struct Bkeys bkey[];

// 定义变量
uint32_t Pwm_Period = 0; //pwm重装载值
float target_Pwm_Dutycycle = 0; //目标占空比
uint32_t target_freq = 0; //目标频率
uint32 Get_Freq = 0;

uint8_t Motor_flag = 0;

uint8_t view = 1;
uint8_t Press_flag = 0;

uint8_t LFD_flag = 0;
uint8_t RFD_flag = 0;
uint8_t LRD_flag = 0;
uint8_t RRD_flag = 0;

bool Door_Dirc = 0;

uint8_t Seat_Angle = 0;
bool Seat_Dirc = 0;

uint8_t LED_Mode = 0;

// ======================== 函数调用 ====================================
void OLED_Proc(void);
void KEY_Proc(void);
void KeySelf_Proc(void);
void LED_Proc(void);

// ======================== 串口回调函数（HEX帧解析） ========================
void Uart1_Callback(const uint8 HwInstance,
                    const Lpuart_Uart_Ip_EventType Event, void *UserData) {

    (void) HwInstance;
    (void) UserData;
    uint8_t receivedByte = 0U;
    volatile Lpuart_Uart_Ip_StatusType lpuartStatus;

    // 处理单字节接收完成事件（RX_FULL）
    if (Event == LPUART_UART_IP_EVENT_RX_FULL) {
        // 读取本次接收到的字节
        receivedByte = buffer[0];

        // 帧解析状态机
        switch (frameState) {
            case FRAME_STATE_IDLE:
                // 空闲态：等待帧头FF
                if (receivedByte == FRAME_HEADER) {
                    rxFrameBuffer[0] = receivedByte;  // 保存帧头
                    frameState = FRAME_STATE_DATA;     // 切换到等待数据态
                    rxFrameIndex = 1U;                 // 下一字节是数据位
                }
                break;

            case FRAME_STATE_DATA:
                // 已收帧头：接收数据字节xx
                rxFrameBuffer[1] = receivedByte;  // 保存数据字节
                frameState = FRAME_STATE_TAIL;    // 切换到等待帧尾态
                rxFrameIndex = 2U;                // 下一字节是帧尾
                break;

            case FRAME_STATE_TAIL:
                // 已收数据：检查帧尾EE
                if (receivedByte == FRAME_TAIL) {
                    // 帧尾合法，解析有效数据
                	Press_flag = 0;
                    rxFrameBuffer[2] = receivedByte;  // 保存帧尾
                    rxDataByte = rxFrameBuffer[1];    // 提取核心数据字节
                    validFrameReceived = 1U;          // 置位有效帧标志
                }
                // 无论帧尾是否合法，都重置状态机等待下一个帧
                frameState = FRAME_STATE_IDLE;
                rxFrameIndex = 0U;
                break;

            default:
                // 异常状态：强制重置
                frameState = FRAME_STATE_IDLE;
                rxFrameIndex = 0U;
                break;
        }

        // 重新配置接收缓冲区，持续接收下一个字节
        Lpuart_Uart_Ip_SetRxBuffer(HwInstance, buffer, 1U);
    }

    // 异常处理：接收状态异常时重启异步接收
    lpuartStatus = Lpuart_Uart_Ip_GetReceiveStatus(HwInstance, &bytesRemaining);
    if (lpuartStatus != LPUART_UART_IP_STATUS_BUSY &&
        lpuartStatus != LPUART_UART_IP_STATUS_SUCCESS) {
        Lpuart_Uart_Ip_AsyncReceive(HwInstance, buffer, 1U);
    }
}
// =========================================================================

/*
 * 输入当前重装载值与期待占空比,返回值可以作为参数直接输入函数
 * Period 为重装载值
 * targetDutycycle 取值范围为0-1,如需要50%占空比 则输入0.5
 *
 * */
uint32_t setDutyCycle(uint32_t Period, float targetDutycycle) {
    uint32_t dutycycle = fabs(Period * targetDutycycle);
    return dutycycle;
}

/*
 * 输入Emios外设频率与期待PWM输出频率,返回值可以作为参数直接输入函数
 * Emios_clk 为重装载值
 * targetPwmFreq 取值单位为hz,,例如需要10Khz频率, 则输入10000.
 *
 * */
uint32_t setFrequency(uint32_t Emios_clk, float targetPwmFreq) {
    uint32_t period = fabs(Emios_clk / targetPwmFreq);
    return period;
}

// PIT 中断回调函数（中断服务函数的核心逻辑）
void PIT_0_Notification(void)
{
    Key_Proc();
}

int main(void)
{
    /* Write your code here */

                                                                                                                                                                                                                                                                                                                                                                                                                                     Clock_Ip_Init(&Clock_Ip_aClockConfig[0]);
    IntCtrl_Ip_Init(&IntCtrlConfig_0);


    Get_Freq = Clock_Ip_GetClockFrequency(CORE_CLK);

    Siul2_Port_Ip_Init(NUM_OF_CONFIGURED_PINS0, g_pin_mux_InitConfigArr0);

    delay_init(Get_Freq / 1000000); //初始化延迟函数需要核心频率,把读取到的频率传入函数。

    Lpuart_Uart_Ip_Init(LPUART6_INSTANCE, &Lpuart_Uart_Ip_xHwConfigPB_6);
    Lpi2c_Ip_MasterInit(I2C_MASTER_INSTANCE, &I2c_Lpi2cMasterChannel0);

    /* 初始化周期定时器 */
    Pit_Ip_Init(PIT_INST_0, &PIT_0_InitConfig_PB);
    /* 初始化周期定时器通道0 */
    Pit_Ip_InitChannel(PIT_INST_0, PIT_0_CH_0);
    /* 使能中断 */
    Pit_Ip_EnableChannelInterrupt(PIT_INST_0, CH_0);
    /*
    * 开始定时器
    * 周期计算公式
    * 周期(秒) = 重装载值  / PIT时钟(40mhz)
    * 例:
    * 期望周期为0.5秒 = 200000000(重装载值) / 40000000(PIT外设时钟)
    *  */
    Pit_Ip_StartChannel(PIT_INST_0, CH_0, PIT_PERIOD);//PIT_PERIOD为重装载值 此处设置为40000000

    // 串口1初始化
    IntCtrl_Ip_InstallHandler(LPUART1_IRQn, LPUART_UART_IP_1_IRQHandler, NULL_PTR);
    IntCtrl_Ip_EnableIrq(LPUART1_IRQn);
    Lpuart_Uart_Ip_Init(LPUART1_INSTANCE, &Lpuart_Uart_Ip_xHwConfigPB_1);
    Lpuart_Uart_Ip_AsyncReceive(LPUART1_INSTANCE, buffer, 1U); // 启动单字节异步接收

    // 中断控制器驱动的 “使能中断” 函数
    IntCtrl_Ip_EnableIrq(PIT0_IRQn);

    // PWM配置
    Emios_Mcl_Ip_Init(INSTANCE_1, &Emios_Mcl_Ip_1_Config_BOARD_INITPERIPHERALS);
    Emios_Pwm_Ip_InitChannel(INSTANCE_1, &Emios_Pwm_Ip_I1_Ch12); //PTA29

    /*
     * Get_Freq 变量为核心频率,此工程emios外设时钟与核心频率相等,所以可以直接使用
     * 设置目标频率为10khz
     * 然后将返回值导入频率配置函数即可得到预期的频率
     * */
    Pwm_Period = setFrequency(Get_Freq, 10000);
    /*
     *  PWM频率计算公式 频率 = (Emios总线频率(160mhz) / period)
     *  Emios通道时钟由23通道提供,所以更改23通道时钟,就可以改变pwm频率
     * */
    Emios_Mcl_Ip_SetCounterBusPeriod(INSTANCE_1, CHANNEL_23, Pwm_Period);

    /*    占空比公式  占空比 = (dutycycle / period ) , dutycycle大于period,则输出100%占空比*/
    Emios_Pwm_Ip_SetDutyCycle(INSTANCE_1, CHANNEL_12, 0);

    StepMotor_Init();
    DrcMotor_Init();

    oled_init(); //OLED配置参数初始化
    delay_ms(20);
    LPUART6_printf("Run frequency is %dmhz\r\n", Get_Freq / 1000000);

    while (1) {
    	OLED_Proc();
    	KeySelf_Proc();
    	LED_Proc();
        if (validFrameReceived == 1) {
            LCD_clear_L(0, 5); //OLED清行
            LCD_clear_L(0, 6);

            // 格式化显示HEX数据（例如：0x12）
            uint8_t hexDisplayBuf[10] = {0};
            snprintf((char*)hexDisplayBuf, sizeof(hexDisplayBuf), "0x%02X", rxDataByte);
            OLED_ShowString(0, 5, hexDisplayBuf, 16, 0);

            // 串口打印完整帧和解析出的数据
            LPUART1_printf("接收到有效HEX帧: FF %02X EE | 数据字节: 0x%02X\r\n",
                          rxDataByte, rxDataByte);

            // 重置标志位，等待下一个帧
            validFrameReceived = 0U;
            memset(rxFrameBuffer, 0, sizeof(rxFrameBuffer));
        }

    }

    for (;;)
    {
        if(exit_code != 0)
        {
            break;
        }
    }
    return exit_code;
}


void OLED_Proc(void)
{

	if(view == 1)
	{
		OLED_ShowString(16, 0, (uint8_t*) "Smart Cockpit", 16, 0);

        switch(Seat_Angle)
		{
        	case 0:
        		OLED_ShowString(0, 2, (uint8_t*) "Seat_Angle: 30 ", 16, 0);
        		break;
        	case 1:
    			OLED_ShowString(0, 2, (uint8_t*) "Seat_Angle: 60 ", 16, 0);
    			break;
        	case 2:
        		OLED_ShowString(0, 2, (uint8_t*) "Seat_Angle: 90 ", 16, 0);
        		break;
        	case 3:
    			OLED_ShowString(0, 2, (uint8_t*) "Seat_Angle: 120 ", 16, 0);
    			break;
        	case 4:
    			OLED_ShowString(0, 2, (uint8_t*) "Seat_Angle: 150 ", 16, 0);
    			break;
        	default:
        		break;
		}
        switch(Door_Dirc)
        {
        	case 0:
        		OLED_ShowString(0, 4, (uint8_t*) "Door_Sta: Close", 16, 0);
        		break;
        	case 1:
        		OLED_ShowString(0, 4, (uint8_t*) "Door_Sta: Open ", 16, 0);
        		break;

        }
        switch(LED_Mode)
        {
        	case 0:
        		OLED_ShowString(0, 6, (uint8_t*) "Light: Close", 16, 0);
        		break;
        	case 1:
        		OLED_ShowString(0, 6, (uint8_t*) "Light: Far  ", 16, 0);
        		break;
        	case 2:
        		OLED_ShowString(0, 6, (uint8_t*) "Light: Near ", 16, 0);
        		break;
        	case 3:
        		OLED_ShowString(0, 6, (uint8_t*) "Light: blink", 16, 0);
        		break;


        }

	}else if(view == 2)
	{
		OLED_write_number(64, 6, LED_Mode, 8, 0);

		OLED_ShowString(16, 0, (uint8_t*) "Prame View", 16, 0);
        /*OLED显示*/
        OLED_ShowString(0, 2, (uint8_t*) "CYCLE:        %", 8, 0);
        OLED_ShowString(0, 3, (uint8_t*) "PERIOD:       HZ", 8, 0);

        LCD_clear_L_POS(64, 108, 2);
        OLED_write_number(64, 2, fabs(target_Pwm_Dutycycle * 100), 8, 0);
        LCD_clear_L_POS(64, 108, 3);
        OLED_write_number(64, 3, target_freq, 8, 0);



        /*OLED显示*/
	}else if(view == 3)
	{
		OLED_ShowString(16, 0, (uint8_t*) "Communication", 16, 0);
	}
}

void KeySelf_Proc(void)
{
    if(bkey[BTN1_PRES].short_flag == 1)
    {
    	OLED_Clear();
    	view++;
    	if(view > 3)
    		view = 1;
        LPUART6_printf("KEY1 Press\r\n");
        bkey[BTN1_PRES].short_flag = 0;
    }
    if(bkey[BTN1_PRES].long_flag == 1)
    {
        LPUART6_printf("KEY1Long Press\r\n");
        bkey[BTN1_PRES].long_flag = 0;
    }
    if(view == 1)
    {
        if(bkey[BTN2_PRES].short_flag == 1)
        {

        	if(Seat_Dirc == 0)
        	{
        	    Seat_Angle++;
        	    StepMotor_Angle(30, Forward_High);
        	}

        	else
        	{
        		Seat_Angle--;
        		StepMotor_Angle(30, Reverse_High);
        	}

        	if(Seat_Angle > 3 || Seat_Angle < 1)
        		Seat_Dirc = !Seat_Dirc;

            LPUART6_printf("KEY2 Press\r\n");
            bkey[BTN2_PRES].short_flag = 0;
        }
        if(bkey[BTN2_PRES].long_flag == 1)
        {
            LPUART6_printf("KEY2Long Press\r\n");

        	if(Door_Dirc == 0)
        	{
    			DrcMotor_Control(LFD, FORWARD);
    			DrcMotor_Control(RFD, FORWARD);
    			DrcMotor_Control(LRD, FORWARD);
    			DrcMotor_Control(RRD, FORWARD);
    			delay_ms(3000);
    			DrcMotor_Control(LFD, STOP);
    			DrcMotor_Control(RFD, STOP);
    			DrcMotor_Control(LRD, STOP);
    			DrcMotor_Control(RRD, STOP);

        	}else if(Door_Dirc == 1)
        	{

    			DrcMotor_Control(LFD, REVERSE);
    			DrcMotor_Control(RFD, REVERSE);
    			DrcMotor_Control(LRD, REVERSE);
    			DrcMotor_Control(RRD, REVERSE);
    			delay_ms(3000);
    			DrcMotor_Control(LFD, STOP);
    			DrcMotor_Control(RFD, STOP);
    			DrcMotor_Control(LRD, STOP);
    			DrcMotor_Control(RRD, STOP);
        	}
        	Door_Dirc = !Door_Dirc;

            bkey[BTN2_PRES].long_flag = 0;
        }
        if(bkey[BTN3_PRES].short_flag == 1)
        {
        	LED_Mode++;
        	if(LED_Mode > 3)
        		LED_Mode = 0;
            LPUART6_printf("KEY3 Press\r\n");
            bkey[BTN3_PRES].short_flag = 0;
        }
        if(bkey[BTN3_PRES].long_flag == 1)
        {


            LPUART6_printf("KEY3Long Press\r\n");
            bkey[BTN3_PRES].long_flag = 0;
        }

    }


}


void KEY_Proc(void)
{
	if(rxDataByte == 0x01 && Press_flag == 0)
	{
		Press_flag = 1;
	}
	if(rxDataByte == 0x05 && Press_flag == 0)
	{
		Press_flag = 1;
		if(LFD_flag == 0)
		{
			DrcMotor_Control(LFD, FORWARD);
			delay_ms(3000);
			DrcMotor_Control(LFD, STOP);
			LFD_flag = !LFD_flag;
		}else if(LFD_flag == 1)
		{
			DrcMotor_Control(LFD, REVERSE);
			delay_ms(3000);
			DrcMotor_Control(LFD, STOP);
			LFD_flag = !LFD_flag;
		}

	}
	if(rxDataByte == 0x06 && Press_flag == 0)
	{
		Press_flag = 1;
		if(RFD_flag == 0)
		{
			DrcMotor_Control(RFD, FORWARD);
			delay_ms(3000);
			DrcMotor_Control(RFD, STOP);
			RFD_flag = !RFD_flag;
		}else if(RFD_flag == 1)
		{
			DrcMotor_Control(RFD, REVERSE);
			delay_ms(3000);
			DrcMotor_Control(RFD, STOP);
			RFD_flag = !RFD_flag;
		}

	}
	if(rxDataByte == 0x07 && Press_flag == 0)
	{
		Press_flag = 1;
		if(LRD_flag == 0)
		{
			DrcMotor_Control(LRD, FORWARD);
			delay_ms(3000);
			DrcMotor_Control(LRD, STOP);
			LRD_flag = !LRD_flag;
		}else if(LRD_flag == 1)
		{
			DrcMotor_Control(LRD, REVERSE);
			delay_ms(3000);
			DrcMotor_Control(LRD, STOP);
			LRD_flag = !LRD_flag;
		}


	}
	if(rxDataByte == 0x08 && Press_flag == 0)
	{
		Press_flag = 1;
		if(RRD_flag == 0)
		{
			DrcMotor_Control(RRD, FORWARD);
			delay_ms(3000);
			DrcMotor_Control(RRD, STOP);
			RRD_flag = !RRD_flag;
		}else if(RRD_flag == 1)
		{
			DrcMotor_Control(RRD, REVERSE);
			delay_ms(3000);
			DrcMotor_Control(RRD, STOP);
			RRD_flag = !RRD_flag;
		}
	}



	if(rxDataByte == 0x0E && Press_flag == 0)
	{
		Press_flag = 1;
		OLED_Clear();
		view++;
		if(view > 3)
			view = 3;


	}else if(rxDataByte == 0x0D && Press_flag == 0)
	{
		Press_flag = 1;
		OLED_Clear();
		view--;
		if(view < 1)
			view = 1;
	}

}




void LED_Proc(void)
{

	if(LED_Mode == 1)
	{
		target_freq = 10000;
		Pwm_Period = setFrequency(Get_Freq, target_freq);
		Emios_Mcl_Ip_SetCounterBusPeriod(INSTANCE_1, CHANNEL_23, Pwm_Period);
		LPUART6_printf("PWM频率为 :%d hz ,重装载值 %d\r\n", target_freq, Pwm_Period);

		target_Pwm_Dutycycle = 0.1;
		uint32_t dutycycle_val = setDutyCycle(Pwm_Period,target_Pwm_Dutycycle);
		Emios_Pwm_Ip_SetDutyCycle(INSTANCE_1, CHANNEL_12, dutycycle_val);
		LPUART6_printf("占空比为 :%.1f ,比较值为 %d\r\n", (target_Pwm_Dutycycle * 100.0f), dutycycle_val);
	}
	else if(LED_Mode == 2)
	{
		target_freq = 50000;
		Pwm_Period = setFrequency(Get_Freq, target_freq);
		Emios_Mcl_Ip_SetCounterBusPeriod(INSTANCE_1, CHANNEL_23, Pwm_Period);
		LPUART6_printf("PWM频率为 :%d hz ,重装载值 %d\r\n", target_freq, Pwm_Period);

		target_Pwm_Dutycycle = 0.9;
		uint32_t dutycycle_val = setDutyCycle(Pwm_Period,target_Pwm_Dutycycle);
		Emios_Pwm_Ip_SetDutyCycle(INSTANCE_1, CHANNEL_12, dutycycle_val);
		LPUART6_printf("占空比为 :%.1f ,比较值为 %d\r\n", (target_Pwm_Dutycycle * 100.0f), dutycycle_val);
	}
	else if(LED_Mode == 3)
	{
		target_freq = 50000;
		Pwm_Period = setFrequency(Get_Freq, target_freq);
		Emios_Mcl_Ip_SetCounterBusPeriod(INSTANCE_1, CHANNEL_23, Pwm_Period);
		LPUART6_printf("PWM频率为 :%d hz ,重装载值 %d\r\n", target_freq, Pwm_Period);

		for(int i = 0; i < 100; i ++)
		{
			target_Pwm_Dutycycle = i / 10.0;
			uint32_t dutycycle_val = setDutyCycle(Pwm_Period,target_Pwm_Dutycycle);
			Emios_Pwm_Ip_SetDutyCycle(INSTANCE_1, CHANNEL_12, dutycycle_val);
			LPUART6_printf("占空比为 :%.1f ,比较值为 %d\r\n", (target_Pwm_Dutycycle * 100.0f), dutycycle_val);
		}
	}



}

/** @} */

```



### Motor.c

````c
/*
 * StepperMotor.c
 *
 *  Created on: 2025年12月10日
 *      Author: Zer02
 */
#include "Mcal.h"

#include"system.h"
#include"key.h"
#include"delay.h"
#include "StepperMotor.h"

void StepMotor_OneCircle(uint16_t Speed)
{
	Siul2_Dio_Ip_WritePin(MOTOR_IN1_PORT, MOTOR_IN1_PIN, 1U);
	Siul2_Dio_Ip_WritePin(MOTOR_IN2_PORT, MOTOR_IN2_PIN, 0U);
	Siul2_Dio_Ip_WritePin(MOTOR_IN3_PORT, MOTOR_IN3_PIN, 0U);
	Siul2_Dio_Ip_WritePin(MOTOR_IN4_PORT, MOTOR_IN4_PIN, 0U);
	delay_ms(Speed);

	Siul2_Dio_Ip_WritePin(MOTOR_IN2_PORT, MOTOR_IN2_PIN, 1U);
	Siul2_Dio_Ip_WritePin(MOTOR_IN1_PORT, MOTOR_IN1_PIN, 0U);
	Siul2_Dio_Ip_WritePin(MOTOR_IN3_PORT, MOTOR_IN3_PIN, 0U);
	Siul2_Dio_Ip_WritePin(MOTOR_IN4_PORT, MOTOR_IN4_PIN, 0U);
	delay_ms(Speed);

	Siul2_Dio_Ip_WritePin(MOTOR_IN3_PORT, MOTOR_IN3_PIN, 1U);
	Siul2_Dio_Ip_WritePin(MOTOR_IN1_PORT, MOTOR_IN1_PIN, 0U);
	Siul2_Dio_Ip_WritePin(MOTOR_IN2_PORT, MOTOR_IN2_PIN, 0U);
	Siul2_Dio_Ip_WritePin(MOTOR_IN4_PORT, MOTOR_IN4_PIN, 0U);
	delay_ms(Speed);

	Siul2_Dio_Ip_WritePin(MOTOR_IN4_PORT, MOTOR_IN4_PIN, 1U);
	Siul2_Dio_Ip_WritePin(MOTOR_IN1_PORT, MOTOR_IN1_PIN, 0U);
	Siul2_Dio_Ip_WritePin(MOTOR_IN2_PORT, MOTOR_IN2_PIN, 0U);
	Siul2_Dio_Ip_WritePin(MOTOR_IN3_PORT, MOTOR_IN3_PIN, 0U);
	delay_ms(Speed);

}

// 四相八拍驱动（力矩翻倍，支持更快速度）
void StepMotor_HighSpeed(uint16_t Speed)
{
    // 八拍时序（1100→0110→0011→1001→1100...），每次2相通电
    Siul2_Dio_Ip_WritePin(MOTOR_IN1_PORT, MOTOR_IN1_PIN, 1U);
    Siul2_Dio_Ip_WritePin(MOTOR_IN2_PORT, MOTOR_IN2_PIN, 1U);
    Siul2_Dio_Ip_WritePin(MOTOR_IN3_PORT, MOTOR_IN3_PIN, 0U);
    Siul2_Dio_Ip_WritePin(MOTOR_IN4_PORT, MOTOR_IN4_PIN, 0U);
    delay_ms(Speed);

    Siul2_Dio_Ip_WritePin(MOTOR_IN1_PORT, MOTOR_IN1_PIN, 0U);
    Siul2_Dio_Ip_WritePin(MOTOR_IN2_PORT, MOTOR_IN2_PIN, 1U);
    Siul2_Dio_Ip_WritePin(MOTOR_IN3_PORT, MOTOR_IN3_PIN, 1U);
    Siul2_Dio_Ip_WritePin(MOTOR_IN4_PORT, MOTOR_IN4_PIN, 0U);
    delay_ms(Speed);

    Siul2_Dio_Ip_WritePin(MOTOR_IN1_PORT, MOTOR_IN1_PIN, 0U);
    Siul2_Dio_Ip_WritePin(MOTOR_IN2_PORT, MOTOR_IN2_PIN, 0U);
    Siul2_Dio_Ip_WritePin(MOTOR_IN3_PORT, MOTOR_IN3_PIN, 1U);
    Siul2_Dio_Ip_WritePin(MOTOR_IN4_PORT, MOTOR_IN4_PIN, 1U);
    delay_ms(Speed);

    Siul2_Dio_Ip_WritePin(MOTOR_IN1_PORT, MOTOR_IN1_PIN, 1U);
    Siul2_Dio_Ip_WritePin(MOTOR_IN2_PORT, MOTOR_IN2_PIN, 0U);
    Siul2_Dio_Ip_WritePin(MOTOR_IN3_PORT, MOTOR_IN3_PIN, 0U);
    Siul2_Dio_Ip_WritePin(MOTOR_IN4_PORT, MOTOR_IN4_PIN, 1U);
    delay_ms(Speed);
}


void StepMotor_Stop()
{
	Siul2_Dio_Ip_WritePin(MOTOR_IN1_PORT, MOTOR_IN1_PIN, 0U);
	Siul2_Dio_Ip_WritePin(MOTOR_IN2_PORT, MOTOR_IN2_PIN, 0U);
	Siul2_Dio_Ip_WritePin(MOTOR_IN3_PORT, MOTOR_IN3_PIN, 0U);
	Siul2_Dio_Ip_WritePin(MOTOR_IN4_PORT, MOTOR_IN4_PIN, 0U);
}

void StepMotor_Angle(uint16_t angle, uint8_t mode)
{
	if(angle <= 360)
	{
		for(int i = 0; i <= ((8 * 64 * angle) / 360); i++)
		{
			if(mode == 1)
				StepMotor_OneCircle(5);
			else if(mode == 2)
				StepMotor_HighSpeed(2);
		}
	}
}

void StepMotor_Circle(uint16_t circle, uint8_t mode)
{
	for(int i = 0; i <= (8 * 64 * circle) ; i++)
	{
		if(mode == 1)
			StepMotor_OneCircle(5);
		else if(mode == 2)
			StepMotor_HighSpeed(2);
	}
}



````



### Motor.h

````c
/*
 * StepperMotor.h
 *
 *  Created on: 2025年12月10日
 *      Author: Zer02
 */


#ifndef STEPPERMOTOR_H_
#define STEPPERMOTOR_H_

#include "system.h"
#include <stdio.h>
#include <stdint.h>
#include "sys.h"
#include "delay.h"


#define MOTOR_IN1_PORT          PTD_H_HALF
#define MOTOR_IN1_PIN           11u
#define MOTOR_IN2_PORT          PTD_H_HALF
#define MOTOR_IN2_PIN           12u
#define MOTOR_IN3_PORT          PTD_H_HALF
#define MOTOR_IN3_PIN           13u
#define MOTOR_IN4_PORT          PTD_H_HALF
#define MOTOR_IN4_PIN           14u


void StepMotor_Angle(uint16_t angle, uint8_t mode);
void StepMotor_Circle(uint16_t circle, uint8_t mode);
void StepMotor_Stop(void);


#endif


````



### key.c

````c
/*
 * key.c
 *
 *  Created on: 2022年3月26日
 *      Author: Administrator
 */

#include"system.h"
#include"key.h"
#include"delay.h"

///*0为单次模式 1为连续模式*/
//unsigned char  KEY_Proc (unsigned char mode)
//{
//    static unsigned char key_up=1;     //按键松开标志
//    if(mode==1)key_up=1;    //支持连按
//
//    if(key_up&&(BTN1==1||BTN2==1||BTN3==1))
//    {
//        delay_ms(10);
//        key_up=0;
//        if(BTN1==1)       return BTN1_PRES;
//        else if(BTN2==1)  return BTN2_PRES;
//        else if(BTN3==1)  return BTN3_PRES;
//
//    }else if(BTN1==0&&BTN2==0&&BTN3==0)key_up=1;
//    return 0;
//}

struct Bkeys bkey[4]={0, 0, 0, 0, 0, 0, 0};

uint8_t Key_read()
{
	if(BTN1 == 1) return BTN1_PRES;
	else if(BTN2 == 1) return BTN2_PRES;
	else if(BTN3 == 1) return BTN3_PRES;
	else return 0;
}

void Key_Proc()
{
	uint8_t key_sta = Key_read();
	if(key_sta!=0)
	{
		bkey[key_sta].age++;
		if(bkey[key_sta].age == 2)
			bkey[key_sta].short_flag=  1;
	}
	else
	{
		for(int i = 0; i < 5; i++) bkey[i].age=0;
	}
}


````



### Key.h

````c
/*==================================================================================================
*   Project              : RTD AUTOSAR 4.7
*   Platform             : CORTEXM
*   Peripheral           : S32K3XX
*   Dependencies         : none
*
*   Autosar Version      : 4.7.0
*   Autosar Revision     : ASR_REL_4_7_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 3.0.0
*   Build Version        : S32K3_RTD_3_0_0_D2303_ASR_REL_4_7_REV_0000_20230331
*
*   Copyright 2020 - 2023 NXP Semiconductors
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

/**
*   @file main.c
*
*   @addtogroup main_module main module documentation
*   @{
*/

/* Including necessary configuration files. */
#include "Mcal.h"

volatile int exit_code = 0;
/* User includes */
#include "sys.h"
#include "uart.h"
#include "delay.h"
#include "key.h"
#include "StepperMotor.h"
#include "DirectMotor.h"
#include "string.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>

/*!
  \brief The main function for the project.
  \details The startup initialization sequence is the following:
 * - startup asm routine
 * - main()
*/

// 串口部分设置
#define LPUART6_INSTANCE  6U
#define LPUART1_INSTANCE  1U  // 修正重复定义问题
// PWM设置
#define INSTANCE_1        (uint8)1U
#define CHANNEL_12        (uint8)12U
#define CHANNEL_23        (uint8)23U

// 定时器部分设置
/* PIT instance used - 0 */
#define PIT_INST_0 0U
/* PIT Channel used - 0 */
#define CH_0 0U
/* PIT time-out period - equivalent to 1s */
#define PIT_PERIOD 800000

// ======================== HEX帧解析相关定义 ========================
// 帧格式：FF(帧头) + xx(数据字节) + EE(帧尾)
#define FRAME_HEADER 0xFF
#define FRAME_TAIL   0xEE
#define FRAME_LENGTH 3U  // 帧总长度

// 帧接收状态机枚举
typedef enum {
    FRAME_STATE_IDLE,    // 空闲态，等待帧头FF
    FRAME_STATE_DATA,    // 已收帧头，等待数据字节xx
    FRAME_STATE_TAIL     // 已收数据，等待帧尾EE
} FrameReceiveStateType;

// 帧接收相关变量
static FrameReceiveStateType frameState = FRAME_STATE_IDLE;  // 帧接收状态
static uint8_t rxFrameBuffer[FRAME_LENGTH] = {0};           // 帧接收缓冲区
static uint8_t rxFrameIndex = 0U;                            // 帧接收字节索引
uint8_t validFrameReceived = 0U;                            // 有效帧接收完成标志
uint8_t rxDataByte = 0U;                                    // 解析出的有效数据字节（xx）
// =========================================================================

// 仅用于接收单个字
uint8_t buffer[1] = {0};
uint32_t bytesRemaining;

volatile uint8_t pit_flag = 0;

extern struct Bkeys bkey[];

uint8_t Motor_flag = 0;

// ======================== 串口回调函数（HEX帧解析） ========================
void Uart1_Callback(const uint8 HwInstance,
                    const Lpuart_Uart_Ip_EventType Event, void *UserData) {

    (void) HwInstance;
    (void) UserData;
    uint8_t receivedByte = 0U;
    volatile Lpuart_Uart_Ip_StatusType lpuartStatus;

    // 处理单字节接收完成事件（RX_FULL）
    if (Event == LPUART_UART_IP_EVENT_RX_FULL) {
        // 读取本次接收到的字节
        receivedByte = buffer[0];

        // 帧解析状态机
        switch (frameState) {
            case FRAME_STATE_IDLE:
                // 空闲态：等待帧头FF
                if (receivedByte == FRAME_HEADER) {
                    rxFrameBuffer[0] = receivedByte;  // 保存帧头
                    frameState = FRAME_STATE_DATA;     // 切换到等待数据态
                    rxFrameIndex = 1U;                 // 下一字节是数据位
                }
                break;

            case FRAME_STATE_DATA:
                // 已收帧头：接收数据字节xx
                rxFrameBuffer[1] = receivedByte;  // 保存数据字节
                frameState = FRAME_STATE_TAIL;    // 切换到等待帧尾态
                rxFrameIndex = 2U;                // 下一字节是帧尾
                break;

            case FRAME_STATE_TAIL:
                // 已收数据：检查帧尾EE
                if (receivedByte == FRAME_TAIL) {
                    // 帧尾合法，解析有效数据
                    rxFrameBuffer[2] = receivedByte;  // 保存帧尾
                    rxDataByte = rxFrameBuffer[1];    // 提取核心数据字节
                    validFrameReceived = 1U;          // 置位有效帧标志
                }
                // 无论帧尾是否合法，都重置状态机等待下一个帧
                frameState = FRAME_STATE_IDLE;
                rxFrameIndex = 0U;
                break;

            default:
                // 异常状态：强制重置
                frameState = FRAME_STATE_IDLE;
                rxFrameIndex = 0U;
                break;
        }

        // 重新配置接收缓冲区，持续接收下一个字节
        Lpuart_Uart_Ip_SetRxBuffer(HwInstance, buffer, 1U);
    }

    // 异常处理：接收状态异常时重启异步接收
    lpuartStatus = Lpuart_Uart_Ip_GetReceiveStatus(HwInstance, &bytesRemaining);
    if (lpuartStatus != LPUART_UART_IP_STATUS_BUSY &&
        lpuartStatus != LPUART_UART_IP_STATUS_SUCCESS) {
        Lpuart_Uart_Ip_AsyncReceive(HwInstance, buffer, 1U);
    }
}
// =========================================================================

/*
 * 输入当前重装载值与期待占空比,返回值可以作为参数直接输入函数
 * Period 为重装载值
 * targetDutycycle 取值范围为0-1,如需要50%占空比 则输入0.5
 *
 * */
uint32_t setDutyCycle(uint32_t Period, float targetDutycycle) {
    uint32_t dutycycle = fabs(Period * targetDutycycle);
    return dutycycle;
}

/*
 * 输入Emios外设频率与期待PWM输出频率,返回值可以作为参数直接输入函数
 * Emios_clk 为重装载值
 * targetPwmFreq 取值单位为hz,,例如需要10Khz频率, 则输入10000.
 *
 * */
uint32_t setFrequency(uint32_t Emios_clk, float targetPwmFreq) {
    uint32_t period = fabs(Emios_clk / targetPwmFreq);
    return period;
}

// PIT 中断回调函数（中断服务函数的核心逻辑）
void PIT_0_Notification(void)
{
    Key_Proc();
}

int main(void)
{
    /* Write your code here */
    uint32 Get_Freq = 0;
    Clock_Ip_Init(&Clock_Ip_aClockConfig[0]);
    IntCtrl_Ip_Init(&IntCtrlConfig_0);
    // 定义变量
    uint32_t Pwm_Period = 0; //pwm重装载值
    float target_Pwm_Dutycycle = 0; //目标占空比
    uint32_t target_freq = 0; //目标频率

    Get_Freq = Clock_Ip_GetClockFrequency(CORE_CLK);

    Siul2_Port_Ip_Init(NUM_OF_CONFIGURED_PINS0, g_pin_mux_InitConfigArr0);

    delay_init(Get_Freq / 1000000); //初始化延迟函数需要核心频率,把读取到的频率传入函数。

    Lpuart_Uart_Ip_Init(LPUART6_INSTANCE, &Lpuart_Uart_Ip_xHwConfigPB_6);
    Lpi2c_Ip_MasterInit(I2C_MASTER_INSTANCE, &I2c_Lpi2cMasterChannel0);

    /* 初始化周期定时器 */
    Pit_Ip_Init(PIT_INST_0, &PIT_0_InitConfig_PB);
    /* 初始化周期定时器通道0 */
    Pit_Ip_InitChannel(PIT_INST_0, PIT_0_CH_0);
    /* 使能中断 */
    Pit_Ip_EnableChannelInterrupt(PIT_INST_0, CH_0);
    /*
    * 开始定时器
    * 周期计算公式
    * 周期(秒) = 重装载值  / PIT时钟(40mhz)
    * 例:
    * 期望周期为0.5秒 = 200000000(重装载值) / 40000000(PIT外设时钟)
    *  */
    Pit_Ip_StartChannel(PIT_INST_0, CH_0, PIT_PERIOD);//PIT_PERIOD为重装载值 此处设置为40000000

    // 串口1初始化
    IntCtrl_Ip_InstallHandler(LPUART1_IRQn, LPUART_UART_IP_1_IRQHandler, NULL_PTR);
    IntCtrl_Ip_EnableIrq(LPUART1_IRQn);
    Lpuart_Uart_Ip_Init(LPUART1_INSTANCE, &Lpuart_Uart_Ip_xHwConfigPB_1);
    Lpuart_Uart_Ip_AsyncReceive(LPUART1_INSTANCE, buffer, 1U); // 启动单字节异步接收

    // 中断控制器驱动的 “使能中断” 函数
    IntCtrl_Ip_EnableIrq(PIT0_IRQn);

    // PWM配置
    Emios_Mcl_Ip_Init(INSTANCE_1, &Emios_Mcl_Ip_1_Config_BOARD_INITPERIPHERALS);
    Emios_Pwm_Ip_InitChannel(INSTANCE_1, &Emios_Pwm_Ip_I1_Ch12); //PTA29

    /*
     * Get_Freq 变量为核心频率,此工程emios外设时钟与核心频率相等,所以可以直接使用
     * 设置目标频率为10khz
     * 然后将返回值导入频率配置函数即可得到预期的频率
     * */
    Pwm_Period = setFrequency(Get_Freq, 10000);
    /*
     *  PWM频率计算公式 频率 = (Emios总线频率(160mhz) / period)
     *  Emios通道时钟由23通道提供,所以更改23通道时钟,就可以改变pwm频率
     * */
    Emios_Mcl_Ip_SetCounterBusPeriod(INSTANCE_1, CHANNEL_23, Pwm_Period);

    /*    占空比公式  占空比 = (dutycycle / period ) , dutycycle大于period,则输出100%占空比*/
    Emios_Pwm_Ip_SetDutyCycle(INSTANCE_1, CHANNEL_12, 0);

    StepMotor_Init();
    DrcMotor_Init();

    oled_init(); //OLED配置参数初始化
    delay_ms(20);
    LPUART6_printf("Run frequency is %dmhz\r\n", Get_Freq / 1000000);

    OLED_ShowString(16, 1, (uint8_t*) " ZeeRooTwo", 8, 0);

    while (1) {

        if (validFrameReceived == 1) {
            LCD_clear_L(0, 5); //OLED清行
            LCD_clear_L(0, 6);

            // 格式化显示HEX数据（例如：0x12）
            uint8_t hexDisplayBuf[10] = {0};
            snprintf((char*)hexDisplayBuf, sizeof(hexDisplayBuf), "0x%02X", rxDataByte);
            OLED_ShowString(0, 5, hexDisplayBuf, 16, 0);

            // 串口打印完整帧和解析出的数据
            LPUART1_printf("接收到有效HEX帧: FF %02X EE | 数据字节: 0x%02X\r\n",
                          rxDataByte, rxDataByte);

            // 重置标志位，等待下一个帧
            validFrameReceived = 0U;
            memset(rxFrameBuffer, 0, sizeof(rxFrameBuffer));
        }


        if(Motor_flag == 1)
        {
            DrcMotor_Control(1, 1);
            delay_ms(500);
            DrcMotor_Control(2, 1);
            delay_ms(500);
            DrcMotor_Control(3, 1);
            delay_ms(500);
            DrcMotor_Control(4, 1);
            delay_ms(500);
            Motor_flag = 0;
        }

        if(bkey[BTN1_PRES].short_flag == 1)
        {
            target_Pwm_Dutycycle += 0.1f;
            if (target_Pwm_Dutycycle > 1) {
                target_Pwm_Dutycycle = 0;
            }
            uint32_t dutycycle_val = setDutyCycle(Pwm_Period,target_Pwm_Dutycycle);
            Emios_Pwm_Ip_SetDutyCycle(INSTANCE_1, CHANNEL_12, dutycycle_val);
            LPUART6_printf("占空比为 :%.1f ,比较值为 %d\r\n",
                           target_Pwm_Dutycycle * 100.0f, dutycycle_val);

            LPUART6_printf("KEY1 Press\r\n");
            bkey[BTN1_PRES].short_flag = 0;
        }
        if(bkey[BTN2_PRES].short_flag == 1)
        {
            target_freq += 10000;
            if (target_freq > 100000) {
                target_freq = 10000;
            }
            Pwm_Period = setFrequency(Get_Freq, target_freq);
            Emios_Mcl_Ip_SetCounterBusPeriod(INSTANCE_1, CHANNEL_23,
                                             Pwm_Period);
            LPUART6_printf("PWM频率为 :%d hz ,重装载值 %d\r\n", target_freq,
                           Pwm_Period);

            LPUART6_printf("KEY2 Press\r\n");
            bkey[BTN2_PRES].short_flag = 0;
        }
        if(bkey[BTN3_PRES].short_flag == 1)
        {
            Motor_flag = 1;
            LPUART6_printf("KEY3 Press\r\n");
            bkey[BTN3_PRES].short_flag = 0;
        }

        /*OLED显示*/
        OLED_ShowString(0, 2, (uint8_t*) "CYCLE:        %", 8, 0);
        OLED_ShowString(0, 3, (uint8_t*) "PERIOD:       HZ", 8, 0);

        LCD_clear_L_POS(64, 108, 5);
        OLED_write_number(64, 2, fabs(target_Pwm_Dutycycle * 100), 8, 0);
        LCD_clear_L_POS(64, 108, 6);
        OLED_write_number(64, 3, target_freq, 8, 0);
        /*OLED显示*/
    }

    for (;;)
    {
        if(exit_code != 0)
        {
            break;
        }
    }
    return exit_code;
}




/** @} */

````

